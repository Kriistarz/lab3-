[lab3.md](https://github.com/user-attachments/files/24699047/lab3.md)# lab3-[Uploading lab3.md
# Рязанова Кристина ИТ-8 Лабораторная №3

# Задание 1
## Задача 3
### Текст задачи
Квадрат и Сторона Квадрата.
Создайте сущность Квадрат. Квадрат описывается следующими характеристиками:
 Имеет Точку (из задачи 1.4.1) отмечающую левый верхний угол
 Имеет длину стороны.
 Создается путем указания точки левого верхнего угла и размера стороны
 Создается путем указания координаты xи y левого верхнего угла и размера стороны
 Может быть приведен к строке вида “Квадрат в точке T со стороной N”, где N – длина стороны,
а T – результат приведения к строке верхнего левого угла
 Может возвращать новую Ломаную (из задачи 1.5.7), точки которой соответствуют точкам углов
текущего квадрата.
Необходимо выполнить следующие задачи:
 Создайте Квадрат в точке {5;3} со стороной 23
 Присвойте в ссылку типа Ломаная результат вызова метода получения Ломаной у ранее
созданного квадрата
 Выведите на экран общую длину полученной Ломаной
 Сдвиньте последнюю Точку Ломаной в позицию {15,25}
 Снова выведите на экран длину Ломаной
Измените сущность Квадрат. Гарантируйте, что Квадрату невозможно задать отрицательное
значение длины стороны. При попытке задать сторону равной нулю или менее, выбрасывается
ошибка с соответствующим текстом. Контроль должен осуществляться как во время создания
объекта, так и позднее, в случае если будет необходимо менять размеры Квадрата. Необходимо
предоставить возможность изменения длины стороны Квадрата и возмож
### Алгоритм решения
1. Создание класса и полей
Создаем класс Square, наследуем его от Shape и реализуем HasPolyline.
Добавляем поля: Point (верхний левый угол) и int sideLength (сторона).
2. Защита данных 
В конструкторах и в методе setSideLength добавляем проверку: if (sideLength <= 0).
Если условие верно, выбрасываем IllegalArgumentException. Это гарантирует, что сторона всегда будет положительной.
3. Логика методов
toString: Формируем строку по шаблону: "Квадрат в точке T со стороной N".
getPolyline: Рассчитываем 4 точки углов по часовой стрелке. Добавляем 5-ю точку (равную первой), чтобы контур ломаной замкнулся.
4. Проверка (Тестирование)
Расчет длины: Создаем квадрат (23), получаем ломаную, выводим её длину.
Модификация: Сдвигаем последнюю точку ломаной в {15, 25} и снова меряем длину.
Ошибки: Пытаемся передать -20 в конструктор и сеттер — убеждаемся, что программа выдает ошибку.

# Задание 2
## Задача 4
### Текст задачи
Бинарное дерево.
Необходимо реализовать структуру данных, представляющую собой простейшее бинарное
дерево. Для формирования данного дерева будет использоваться сущность Узел.
Состояние сущности описывается следующими характеристиками:
o Значение, целое число
o Родитель, Узел
o Левый потомок, Узел
o Правый потомок, Узел.
Инициализация сущности выполняется без аргументов.
Поведение сущности описывают следующие действия:
 Добавление значения. При добавлении значения возможно две ситуации
o Для данного узла Значение не было задано ранее. В этом случае оно задается и
работа завершается
o Для данного узла Значение ранее было задано. В этом случае определяется, больше
ли новое значение или меньше-равно чем текущее. Если больше – то значение
добавляется в правый потомок, иначе в левый. Если нужный потомок отсутствует,
то сначала он должен быть создан.
 Удаление значения. В качестве аргумента передается значение, которое нужно удалить.
Если такое значение есть, в самом узле или любом его потомке, то удаляется узел с этим
значением, но все его потомки должны остаться прикрепленными к структуре.
 Проверка на существование значения. В качестве аргумента передается значение, и
возвращается информация о том есть ли такое значение в самом узле или любом его
потомке.
 Приведение к строке. Результатом приведения узла к строке является перечень всех
значений хранимых в данном узле и всех его потомках, которое должно быть получено
левосторонним обходом в глубину.
После реализации сущности, создайте её экземпляр и добавить в него числа: 3 5 4 7 1 2. Выведите
на экран текстовое представление узла.
### Алгоритм решения
1. Структура (Класс Node)
Поля: Значение (value), ссылки на родителя (parent) и двух потомков (left, right).
Инициализация: Пустой узел с null значением.
2. Логика работы
Добавление (addValue): Если узел занят, меньшие или равные числа отправляем влево, большие — вправо. Если потомка нет, создаем его.
Поиск (findValue): Рекурсивно проверяем текущий узел и всех его потомков.
Удаление (removeValue): Находим узел. Если у него есть дети, заменяем его значение на крайнее из поддерева (чтобы не разорвать дерево). Если детей нет — просто удаляем ссылку у родителя.
3. Вывод (toString)
Используем центрированный обход (In-order): сначала левое дерево, потом текущее число, затем правое. Это автоматически выстроит числа по возрастанию.
4. Тест
При вводе 3, 5, 4, 7, 1, 2 дерево распределит их по веткам, а при выводе получится отсортированная строка: 1 2 3 4 5 7.

# Задание 3
## Задача 2
### Текст задачи
Замкнутая ломаная.
Создайте такой подвид сущности Ломанная, полученной в задаче 1.5.7, которая будет
представлять собой замкнутую ломанную линию, то есть последовательность точек,
начинающихся и заканчивающихся на одной и той же точке (см. рисунок). Данная сущность во
всех отношениях совпадает с обычной Ломаной, кроме расчета длины (по очевидным причинам). 
### Алгоритм решения
1. Проектирование (Класс ClosedPolyline)
Наследование: Создаем класс ClosedPolyline, который наследуется от обычной Polyline. Это позволяет переиспользовать список точек и логику хранения.
Конструкторы: Используем super(points), чтобы передать список координат в родительский класс.
2. Логика расчета длины (getLength)
Шаг 1: Вызываем super.getLength(). Это дает сумму расстояний между всеми точками по порядку (от первой до последней).
Шаг 2: Добавляем «замыкающий» отрезок. Если в линии больше одной точки, вычисляем расстояние между самой первой и самой последней точкой по формуле Пифагора.
Результат: Возвращаем полную сумму. Теперь ломаная считается замкнутым контуром.
3. Использование родительских методов
Благодаря наследованию, нам не нужно заново писать методы addPoint, toString или equals. Они работают автоматически.Метод getPoints() позволяет легко получить доступ к списку точек для расчета финального отрезка.
4. Тестирование
Создаем объект ClosedPolyline с набором точек.Вызываем getLength().
Проверяем, что результат больше, чем у обычной ломаной с теми же точками, ровно на длину замыкающей линии.

# Задание 4
## Задача 4
### Текст задачи
Фигуры.
Необходимо продумать структуру и организацию следующих геометрических фигур:
1. Круг. Задается точкой координат центра и радиусом.
2. Квадрат. Рекомендуется взять квадрат полученный в задаче 2.1.3
3. Прямоугольник. Задается точкой координат левого верхнего угла и двумя сторонами.
4. Треугольник. Задается тремя точками координат.
Для каждой фигуры обязательно должна быть возможность рассчитать её площадь
### Алгоритм решения
1.Архитектура (Базовый класс)
Создаем абстрактный класс Shape.Описываем в нем общий контракт — метод getArea(). Это позволяет программе работать с любой фигурой одинаково, не вдаваясь в детали её формы.
2. Реализация фигур (Наследование)
Создаем классы Circle, Square, Rectangle, Triangle.Каждый класс наследует Shape и реализует свою формулу площади (S = pi*r^2, S = a^2, S = w*h, Формула Герона).
Добавляем валидацию: в конструкторах запрещаем отрицательные размеры через IllegalArgumentException.
3. Полиморфизм в testFigures 
(Main)Группировка: Создаем список объектов под общим типом List<Shape>. Несмотря на то, что фигуры разные, Java воспринимает их как «какие-то фигуры».
Единая обработка: В цикле for (Shape shape : figures) вызываем метод getArea().
Динамическое связывание: Программа сама понимает, какую именно формулу вызвать (для круга — одну, для треугольника — другую), основываясь на реальном типе объекта.


# Задание 5
## Задача 5
### Текст задачи
Измерение длины.
Разработайте метод, который принимает набор объектов у которых можно посчитать длину, и
возвращает сумму длин принятых объектов. Измените сущности полученные в задачах 1.5.7
(Ломаная линия) и 1.6.6(Линия) таким образом, что бы их можно было передать в этот метод.
Продемонстрируйте работоспособность метода на примерах.
### Алгоритм решения
1. Создание интерфейса (HasLength)
Вводим общий стандарт: интерфейс с методом double getLength(). Теперь любой объект (линия, ломаная) может рассматриваться просто как «нечто, имеющее длину».
2. Реализация в классах
Добавляем implements HasLength к Line, Polyline и ClosedPolyline.
Каждый класс сам считает свою длину: Линия — по 2 точкам, Ломаная — по всем отрезкам.
3. Универсальный сумматор (LengthsSum)
Создаем класс, который принимает список объектов типа HasLength.
Логика: В цикле вызываем .getLength() у каждого элемента и суммируем результат. Ему не важно, какой именно это объект, если у него есть метод длины.
4. Тест (testGetLength)
Объединяем разные фигуры (линию и ломаные) в один список List<HasLength>.
Передаем список в сумматор и выводим итоговое число.

# Задание 5
## Задача 7
### Текст задачи
Ломай меня полностью.
Разработайте метод, который принимает такой набор объектов, у которых можно получить
ломаную линию, и возвращает их объединение в виде одного объекта типа Ломаная.
Передаваемые в метод объекты должны обладать методом со следующей сигнатурой:
public PolygonalChainget PolygonalChain();
В описанной сигнатуре PolygonalChain это название класса разработанного в задаче 1.5.7. Таким
образом, сущность Квадрат из задачи 3.3.6 должна подходить для передачи в разрабатываемый
метод. Измените ранее созданные сущности Треугольник, Линия, и ЛоманаяЛиния так, чтобы у
них также можно было получить ломаную линию и их можно было бы передать в
разрабатываемый метод. Обратите внимание, что у круга невозможно получить ЛомануюЛинию. 
### Алгоритм решения
1. Интерфейс-объединитель (HasPolyline)
Создаем интерфейс с методом Polyline getPolyline(). Это позволяет работать с разными фигурами как с источниками точек.
Реализуем его в Line, Square, Triangle и Polyline. Круг игнорируем (у него нет углов).
2. Логика сборки (PolylineUtils)
Создаем метод merge, который принимает список объектов HasPolyline.
Действие: В цикле проходим по объектам, забираем у каждого список точек через getPolyline().getPoints() и складываем их в один общий список.
Результат: Создаем и возвращаем одну новую Polyline, содержащую все собранные точки.
3. Проверка (testPolylinesUtils)
Передаем в метод сразу линию, квадрат и треугольник.
На выходе получаем один объект-ломаную, который последовательно описывает контуры всех трех фигур.

# Задание 6
## Задача 4
### Текст задачи
Сравнение ломаных линий.
Измените сущность Ломаная из задачи 1.5.7. Переопределите метод сравнения объектов по
состоянию таким образом, чтобы две ломанные считались одинаковыми тогда, когда все их точки
совпадают.
### Алгоритм решения
1. Подготовка точек (Point)
В классе Point переопределяем equals. Точки равны, только если их координаты X и Y совпадают. Без этого списки сравниваться не будут.
2. Сравнение списков (Polyline)
В классе Polyline в методе equals сравниваем внутренние списки: this.points.equals(other.points).
3. Суть
Метод ArrayList.equals автоматически проходит по всем элементам и проверяет их по порядку.
Если состав точек или их порядок различаются — ломаные считаются разными.
4. Вывод
Для равенства двух ломаных нужно, чтобы они состояли из одинаковых точек в одинаковой последовательности.


# Задание 7
## Задача 1
### Текст задачи
Навести порядок.
Данная задача предполагает реорганизацию ранее написанных классов. Расположите все ранее
написанные классы по пакетам таким образом, чтобы логически близкие классы оказались
сгруппированы друг с другом. Имена пакетов должны иметь как минимум трехсоставную форму,
вида: ru.surname.type. Вместо surname следует подставить свою фамилию, а вместо type
подставить название логического блока. Например, классы описывающие точку, линию, ломаную
линию, фигуру, квадрат, треугольник, круг и прямоугольник можно расположить в пакете
ru.surname.geometry. 
## Задача 2
### Текст задачи
Главный метод.
Создайте пакет ru.surname.main (вместо surname необходимо подставить собственную
фамилию) в котором расположить класс с точкой входа в исполнение программы (public static void
main). Также следует проверить, что ни в одном другом пакете нет классов имеющих точку входа
в исполнение программы. В этом же пакете необходимо расположить класс (или интерфейс) с
методами из задач блока 2.5 и продемонстрировать их работоспособность. 
## Задача 3
### Текст задачи
Возведение в степень.
Создайте метод принимающий две строки, в которых будут записаны числа X и Y. Возвращает
метод результат возведения X в степень Y. Для преобразования строки в число следует
использовать метод Integer.parseInt, а для возведения в степень метод Math.pow. Вызовите
разработанный метод передав туда параметры командной строки полученные точкой входа в
программу. Реализуйте метод так, что бы для возведения в степень и преобразования строки
использовались короткие имена статических методов.
### Алгоритм решения
Создать пакеты по шаблону ru.фамилия.логическийБлок. 
Переместить классы в соответствующие пакеты. 
Реализовать метод для возведения в степень: 
принять две строки, преобразовать через Integer.parseInt, возвести в степень через Math.pow. 
использовать import static для краткости вызова. 
В методе main вызвать этот метод с параметрами из args и вывести результат.

# Задание 8
## Задача 4
### Текст задачи
4.2.4 Клонирование точки.
Измените сущность Точка из 3.6.2.Переопределите метод клонирования, унаследованный от
класса Object, таким образом, чтобы при его вызове возвращался новый объект Точки, значения
полей которого будут копиями оригинальной Точки.
### Алгоритм решения
1. Маркировка (Cloneable)
Добавляем к классу Point интерфейс implements Cloneable. Это разрешает копирование объекта на уровне системы.
2. Реализация (clone)
Переопределяем метод clone() как public.Внутри вызываем (Point) super.clone().Результат: Создается новый объект, в который автоматически копируются значения координат x и y.
3. Проверка независимости
После клонирования p2 = p1.clone() объекты становятся автономными.Если изменить p2, оригинал p1 не изменится. Это доказывает, что создана копия, а не просто ссылка на тот же объект.

…]()
